<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="stylesheet" href="note.css">
</head>

<body>
    <div id="background-marquee" class="marquee"></div>

    <div class="content">
        <div class="left-col">
            <h1>Đôi lời muốn nói</h1>

            <div class="input-box">
                <input type="text" id="nameInput" placeholder="Your name (optional)">
            </div>

            <div class="input-box">
                <textarea id="msgInput" placeholder="Drop your thought..."></textarea>
                <p id="wordCount" style="opacity:.7;font-size:.9rem"></p>
                <button id="postBtn" onclick="sendMessage()">Post Message</button>
            </div>

            <p id="status"></p>

            <div class="desc-box">
                <h3>About this board</h3>
                <p>This is a private space for class 12C2. Feel free to leave your memories,
                    wishes, or secrets here. Please keep it respectful!</p>
            </div>
        </div>

        <div class="right-col">
            <div class="comments-header">
                <button id="readCommentsBtn" aria-haspopup="dialog" aria-controls="commentsReadOverlay"
                    title="Open read mode">Read more</button>
            </div>
            <div id="commentBox" class="comments" aria-live="polite" tabindex="0">
            </div>

            <!-- Read mode overlay (hidden by default) -->
            <div id="commentsReadOverlay" class="comments-overlay" aria-hidden="true">
                <div class="overlay-backdrop" tabindex="-1" data-overlay-backdrop>
                    <div class="overlay-panel" role="dialog" aria-modal="true" aria-labelledby="commentsReadTitle">
                        <div class="overlay-header">
                            <h2 id="commentsReadTitle">Comments — Read more</h2>
                            <div>
                                <button id="closeCommentsRead" aria-label="Close read mode">Close</button>
                            </div>
                        </div>
                        <div id="commentsReadContent" class="comments read-mode" tabindex="0">
                            <!-- Cloned comments will appear here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Determine API origin when serving from Live Server or file://
        const API_ORIGIN = (location.protocol === 'file:' || location.port === '5501') ? 'http://localhost:3000' : '';

        // Persisted collapsed state
        let commentsCollapsed = localStorage.getItem('commentsCollapsed') === '1';

        const msgInput = document.getElementById("msgInput");
        const wordCount = document.getElementById("wordCount");
        const max_word_count = 200;

        msgInput.addEventListener("input", () => {
            let words = msgInput.value.trim().split(/\s+/);
            let count = msgInput.value.trim() === "" ? 0 : words.length;

            if (count > max_word_count) {
                msgInput.value = words.slice(0, max_word_count).join(" ");
                count = max_word_count;
            }

            wordCount.innerText = `${count} / ${max_word_count} words`;

            // auto resize
            msgInput.style.height = "auto";
            msgInput.style.height = msgInput.scrollHeight + "px";

            // enable scrollbar if too tall
            if (msgInput.scrollHeight > 180) {
                msgInput.style.overflowY = "auto";
            } else {
                msgInput.style.overflowY = "hidden";
            }
        });

        // Global variable to store all messages for Read Mode
        let allMessages = [];

        async function loadMessages() {
            try {
                const res = await fetch(`${API_ORIGIN}/messages`);
                const text = await res.text();

                // Parse and reverse the lines to get newest first
                allMessages = text
                    .split('\n')
                    .filter(l => l.trim() !== "")
                    .reverse();

                renderMainFeed();

            } catch (err) {
                console.error("Failed to load messages:", err);
            }
        }

        // Function to render only the top 3 to the main comment box
        function renderMainFeed() {
            const feed = document.getElementById('commentBox');
            feed.innerHTML = "";

            // Take only the first 3 messages
            const recentMessages = allMessages.slice(0, 3);

            if (recentMessages.length === 0) {
                feed.innerHTML = "<p style='opacity:0.5; text-align:center;'>No thoughts yet...</p>";
                return;
            }

            recentMessages.forEach(line => {
                feed.innerHTML += createCommentHTML(line);
            });
        }

        // Helper function to generate the HTML for a single comment
        function createCommentHTML(line) {
            let [name, msg] = line.split('|');
            name = (name || "Anonymous").trim();
            msg = (msg || "").trim();

            return `
                <div class="comment">
                    <div class="avatar">${name[0] || "A"}</div>
                    <div class="body">
                        <div class="name">${name}</div>
                        <div class="time">${new Date().toLocaleString()}</div>
                        <div class="text">${msg}</div>
                    </div>
                </div>
            `;
        }

        async function sendMessage() {
            const input = document.getElementById('msgInput');
            const nameInput = document.getElementById('nameInput');
            const statusEl = document.getElementById('status');
            const postBtn = document.getElementById('postBtn');

            let message = input.value.trim();
            let name = nameInput.value.trim() || "Anonymous";

            if (!message) return;

            const words = message.split(/\s+/);
            if (words.length > 200) {
                statusEl.innerText = `Max 200 words. You're at ${words.length}.`;
                return;
            }

            postBtn.disabled = true;
            statusEl.innerText = 'Sending...';

            try {
                const res = await fetch(`${API_ORIGIN}/send-message`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        name: name || "",
                        message
                    })
                });

                if (!res.ok) {
                    const errText = await res.text().catch(() => res.statusText || 'Error');
                    statusEl.innerText = `Server error: ${errText}`;
                    return;
                }

                const data = await res.json().catch(() => ({}));

                if (data && data.success) {
                    input.value = "";
                    loadMessages();
                    statusEl.innerText = "Message sent!";
                } else {
                    statusEl.innerText = data.error || 'Could not send message.';
                }
            } catch (err) {
                console.error('Network error sending message:', err);
                statusEl.innerText = 'Network error. Are you running the local server?';
            } finally {
                postBtn.disabled = false;
            }
        }

        // Initial load
        loadMessages();

        // Read mode overlay behavior (open near-fullscreen comments with dimmed backdrop)
        (function () {
            const readBtn = document.getElementById('readCommentsBtn');
            const overlay = document.getElementById('commentsReadOverlay');
            const readContent = document.getElementById('commentsReadContent');
            const closeBtn = document.getElementById('closeCommentsRead');
            let lastFocused = null;

            if (!readBtn || !overlay) return;

            function openReadMode() {
                const readContent = document.getElementById('commentsReadContent');
                readContent.innerHTML = '';

                if (allMessages.length === 0) {
                    readContent.innerHTML = "<p style='color:white; opacity:0.5;'>No messages to display.</p>";
                } else {
                    allMessages.forEach(line => {
                        readContent.innerHTML += createCommentHTML(line);
                    });
                }

                overlay.setAttribute('aria-hidden', 'false');
                overlay.classList.add('open');
                document.body.classList.add('comments-read-open');
                lastFocused = document.activeElement;
                closeBtn.focus();
                document.addEventListener('keydown', onReadKeydown);
            }
            function closeReadMode() {
                overlay.setAttribute('aria-hidden', 'true');
                overlay.classList.remove('open');
                document.body.classList.remove('comments-read-open');
                readContent.innerHTML = '';
                document.removeEventListener('keydown', onReadKeydown);
                if (lastFocused) lastFocused.focus();
            }

            function onReadKeydown(e) {
                if (e.key === 'Escape') { e.preventDefault(); closeReadMode(); return; }

                if (e.key === 'Tab') {
                    // Basic focus trap within overlay
                    const focusables = overlay.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                    const list = Array.prototype.filter.call(focusables, f => f.offsetParent !== null && !f.hasAttribute('disabled'));
                    if (list.length === 0) { e.preventDefault(); return; }
                    const first = list[0], last = list[list.length - 1];
                    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
                }
            }

            readBtn.addEventListener('click', openReadMode);
            closeBtn.addEventListener('click', closeReadMode);

            // clicking backdrop closes when clicking outside the panel
            overlay.querySelector('[data-overlay-backdrop]').addEventListener('click', (ev) => {
                if (ev.target === ev.currentTarget) closeReadMode();
            });
        })();
    </script>
    <script>
      /* Sync theme inside iframe with parent's stored theme. Falls back to 'dark' if none saved. */
      (function(){
        function applyThemeFromStorage(){
          try{
            const theme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', theme);
          }catch(e){/* ignore */}
        }

        applyThemeFromStorage();

        // Listen for storage changes from parent window (works cross-window)
        window.addEventListener('storage', (e) => {
          if (e.key === 'theme') applyThemeFromStorage();
        });

        // As a fallback, allow parent to postMessage a theme update
        window.addEventListener('message', (ev) => {
          try{
            const d = ev.data;
            if (d && d.type === 'theme' && d.value) {
              document.documentElement.setAttribute('data-theme', d.value);
            }
          }catch(err){}
        });
      })();
    </script>
</body>

</html>